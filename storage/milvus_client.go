package storage

import (
	"context"
	"log"
	"time"

	"crawlengine/config"
	// "github.com/milvus-io/milvus-sdk-go/v2/client"
	// "github.com/milvus-io/milvus-sdk-go/v2/entity"
)

type WebDocument struct {
	HashID          string    `json:"hash_id"` // Primary Key
	URL             string    `json:"url"`
	HTMLSource      string    `json:"html_source"`
	MainContent     string    `json:"main_content"`
	Title           string    `json:"title"`
	MetaDescription string    `json:"meta_description"`
	CrawledAt       time.Time `json:"crawled_at"`
	// Potentially add Language, PublishDate etc.
	// ContentVector []float32 `json:"content_vector"` // This would be generated by an AI model
}

type MilvusStorer struct {
	// milvusClient client.Client // Actual Milvus client
	cfg *config.MilvusConfig
}

// NewMilvusStorer creates a new Milvus storer.
func NewMilvusStorer(cfg *config.MilvusConfig) (*MilvusStorer, error) {
	// Placeholder for actual Milvus client initialization
	// addr := fmt.Sprintf("%s:%s", cfg.Host, cfg.Port)
	// cli, err := client.NewClient(context.Background(), client.Config{Address: addr})
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to connect to Milvus: %w", err)
	// }
	// log.Printf("Successfully connected to Milvus at %s", addr)

	// TODO: Ensure collection exists with the correct schema
	// This part is crucial and involves defining fields, primary key, indexes (like IVF_FLAT for vectors).
	// For example:
	// schema := &entity.Schema{
	// 	CollectionName: cfg.CollectionName,
	// 	Description:    "Web documents crawled for AI search",
	// 	AutoID:         false,
	// 	Fields: []*entity.Field{
	// 		entity.NewField().WithName("hash_id").WithDataType(entity.FieldTypeVarChar).WithIsPrimaryKey(true).WithMaxLength(64),
	// 		entity.NewField().WithName("url").WithDataType(entity.FieldTypeVarChar).WithMaxLength(2048),
	// 		// Storing full HTML might be very large. Consider alternatives if space/performance is an issue.
	// 		entity.NewField().WithName("html_source").WithDataType(entity.FieldTypeVarChar).WithMaxLength(1000000), // Adjust max length
	// 		entity.NewField().WithName("main_content").WithDataType(entity.FieldTypeVarChar).WithMaxLength(500000), // Adjust
	// 		entity.NewField().WithName("title").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512),
	// 		entity.NewField().WithName("meta_description").WithDataType(entity.FieldTypeVarChar).WithMaxLength(1024),
	// 		entity.NewField().WithName("crawled_at").WithDataType(entity.FieldTypeInt64), // Store as Unix timestamp
	// 		// entity.NewField().WithName("content_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(YOUR_EMBEDDING_DIMENSION),
	// 	},
	// }
	// err = cli.CreateCollection(context.Background(), schema, entity.DefaultShardNumber)
	// if err != nil && !strings.Contains(err.Error(), "already exist") {
	// 	return nil, fmt.Errorf("failed to create collection: %w", err)
	// }

	return &MilvusStorer{cfg: cfg /* milvusClient: cli */}, nil
}

// StoreDocument saves the web document to Milvus.
// In a real implementation, this would involve preparing entities and inserting them.
func (ms *MilvusStorer) StoreDocument(ctx context.Context, doc *WebDocument) error {
	log.Printf("Attempting to store document for URL: %s with ID: %s", doc.URL, doc.HashID)

	// Placeholder for actual Milvus insertion logic
	// columns := []entity.Column{
	// 	entity.NewColumnVarChar("hash_id", []string{doc.HashID}),
	// 	entity.NewColumnVarChar("url", []string{doc.URL}),
	// 	entity.NewColumnVarChar("html_source", []string{doc.HTMLSource}),
	// 	entity.NewColumnVarChar("main_content", []string{doc.MainContent}),
	// 	entity.NewColumnVarChar("title", []string{doc.Title}),
	// 	entity.NewColumnVarChar("meta_description", []string{doc.MetaDescription}),
	// 	entity.NewColumnInt64("crawled_at", []int64{doc.CrawledAt.Unix()}),
	// 	// If you have embeddings:
	// 	// entity.NewColumnFloatVector("content_vector", YOUR_EMBEDDING_DIMENSION, [][]float32{doc.ContentVector}),
	// }
	// _, err := ms.milvusClient.Insert(ctx, ms.cfg.CollectionName, "", columns...)
	// if err != nil {
	// 	return fmt.Errorf("failed to insert document into Milvus (URL: %s, ID: %s): %w", doc.URL, doc.HashID, err)
	// }

	log.Printf("Successfully stored document ID: %s for URL: %s (Simulated)", doc.HashID, doc.URL)
	return nil
}

// Close closes the Milvus client connection.
func (ms *MilvusStorer) Close() {
	// if ms.milvusClient != nil {
	// 	ms.milvusClient.Close()
	// 	log.Println("Milvus client connection closed.")
	// }
}
